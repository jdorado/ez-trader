import sys
import os
from datetime import datetime
from src.data.yfinance_loader import YahooFinanceLoader
from src.data.options_loader import OptionsLoader
from src.strategies.volatility import VolatilityStrategy
from src.core.safety import CorporateActionChecker
from src.core.risk_manager import RiskManager
from src.utils.logger import logger

# Setup
ticker_list = ["HOOD", "CSCO", "AMD"]
loader = YahooFinanceLoader()
opt_loader = OptionsLoader()
safety_checker = CorporateActionChecker()

print(f"--- Debugging Missed Signals for {ticker_list} ---")

for ticker in ticker_list:
    print(f"\nðŸ” Analyzing {ticker}...")
    
    # 1. Safety Check
    safety = safety_checker.check_safety(ticker)
    print(f"Safety Check: {safety}")
    if not safety['safe']:
        print(f"âŒ SKIPPED due to Safety: {safety['reason']}")
        continue
        
    # 2. Data Fetch
    data = loader.get_historical_data(ticker, start_date="2023-01-01")
    if data.empty:
        print("âŒ SKIPPED due to Empty Data")
        continue
        
    # 3. Strategy Run
    strategy = VolatilityStrategy(ticker, z_score_threshold=1.5)
    strategy.on_data({ticker: data})
    signals = strategy.generate_signals()
    
    print(f"Z-Score: {strategy.last_z_score:.4f}")
    print(f"Volatility: {strategy.last_volatility:.4f}")
    
    if not signals:
        print("âŒ NO SIGNAL generated by Strategy")
        continue
        
    print(f"âœ… SIGNAL Generated: {signals[0]}")
    
    # 4. Options Check
    sig = signals[0]
    allocation = sig['allocation']
    print(f"Target Allocation: ${allocation:.2f}")
    
    expiry = opt_loader.get_nearest_expiration(ticker, min_days=2)
    print(f"Expiry: {expiry}")
    
    if expiry:
        chain = opt_loader.get_option_chain(ticker, expiry)
        option_type = 'call' if sig['action'] == 'BUY' else 'put'
        options_df = chain['calls'] if option_type == 'call' else chain['puts']
        
        if options_df.empty:
            print("âŒ NO OPTIONS Data found")
            continue
            
        current_price = loader.get_latest_price(ticker)
        # Simple ATM check
        options_df['abs_diff'] = abs(options_df['strike'] - current_price)
        atm_option = options_df.sort_values('abs_diff').iloc[0]
        cost = atm_option['lastPrice'] * 100
        print(f"ATM Option Cost: ${cost:.2f} (Strike {atm_option['strike']})")
        
        if cost > allocation:
            print(f"âš ï¸ ATM too expensive (> ${allocation:.2f}). Checking OTM...")
            # Check OTM logic
            if option_type == 'call':
                candidates = options_df[options_df['strike'] > current_price].sort_values('strike')
            else:
                candidates = options_df[options_df['strike'] < current_price].sort_values('strike', ascending=False)
            
            found = False
            for _, row in candidates.iterrows():
                c_cost = row['lastPrice'] * 100
                if c_cost > 0 and c_cost <= allocation:
                    print(f"âœ… Found OTM: Strike {row['strike']} @ ${row['lastPrice']:.2f} (Cost ${c_cost:.2f})")
                    found = True
                    break
            if not found:
                print("âŒ FAILED to find affordable OTM option")
        else:
            print("âœ… ATM Option fits budget")
